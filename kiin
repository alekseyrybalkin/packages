#!/bin/bash

# this script depends on (beyond base LFS packages):
# git, mercurial, python 2, sqlite, fakeroot, wget, python2-sh, sudo

KIIN_HOME=/var/kiin
KIIN_DB=$KIIN_HOME/kiin-db/kiin.sqlite3
PACKAGE_MANAGER=rybalkin
ARCH_PACKAGES_REPO=~/sources/packages
ARCH_COMMUNITY_REPO=~/sources/community
SOURCES_HOME=/var/src
umask 0022

usage() {
  echo "usage:"
  echo "  kiin make [lib32]"
  echo "  kiin download"
  echo "  kiin gen-db"
  echo "  kiin list-dups"
  echo "  kiin who-owns </full/path/to/file>"
  echo "  kiin who-uses-dir </full/path/to/dir>"
  echo "  kiin check-conflicts </path/to/package.xz>"
  echo "  kiin list-files </path/to/package.xz>"
  echo "  kiin list-dirs </path/to/package.xz>"
  echo "  kiin install </path/to/package.xz>"
  echo "  kiin upgrade </path/to/package.xz> [noask]"
  echo "  kiin ls"
  echo "  kiin uninstall <package>"
  echo "  kiin db-list-files <package>"
  echo "  kiin db-list-dirs <package>"
  echo "  kiin list-untracked <dir>"
  echo "  kiin check-system-integrity"
  echo "  kiin list-missing"
  echo "  kiin prepare-check-updates"
  echo "  kiin check-updates"
  echo "  kiin update-links <package>"
  echo "  kiin links <package>"
  echo "  kiin linked-by <package>"
  echo "  kiin l <package>"
  echo "  kiin who-uses-now <package>"
  echo "  kiin check-buildorder"
  echo "  kiin rebuild-world"
  echo "  kiin convert-arch-package"
  echo "  kiin list-package-dirs"
}

# for upgrade and uninstall
check_system_packages() {
  case $1 in
    "kiin-git" | "kiin-known" | "filesystem")
      echo "wouldn't want to $2 $1, would ya?"
      exit 1
      ;;
  esac
}

# for upgrade, install and uninstall
recreate_info_dir() {
  cd /usr/share/info
  rm -v dir
  for f in *; do
    install-info $f dir 2>/dev/null
  done
}

if [ -z $1 ]; then
  usage
  exit 0
fi

case $1 in
  "make" | "download" | "convert-arch-package")
    if [ ! -f ./package.sh ]; then
      echo "no package.sh found, goodbye."
      exit 1
    fi
    location=`pwd`
    . ./package.sh

    pkgdir=${location}/kiin-dest
    ;;
esac
case $1 in
  "install" | "upgrade" | "uninstall" | "list-untracked" \
    | "check-system-integrity" | "list-missing" | "who-uses-now")
    if [ `whoami` != 'root' ]; then
      echo "you must be root to run kiin $1"
      exit 1
    fi
    ;;
esac
case $1 in
  "who-owns" | "who-uses-dir" | "check-conflicts" | "list-files" \
    | "list-dirs" | "install" | "upgrade" | "uninstall" | "db-list-files" \
    | "db-list-dirs" | "list-untracked" | "update-links" | "links" \
    | "linked-by" | "l" | "who-uses-now")
    if [ -z $2 ]; then
      echo "usage:" && usage | grep $1
      exit 1
    fi
    ;;
esac
case $1 in
  "uninstall" | "db-list-files" | "db-list-dirs" | "update-links" \
    | "links" | "linked-by" | "l" | "who-uses-now")
    count=`kiin ls | grep "^$2" | wc -l`
    if [ $count = 0 ]; then
      echo "$2 is not installed"
      exit 1
    fi
    if [ $count -gt 1 ]; then
      echo "$2 is ambiguous (" `kiin ls | grep "^$2"` ")"
      exit 1
    fi
    package=`kiin ls | grep "^$2"`
    ;;
esac
case $1 in
  "check-conflicts" | "list-files" | "list-dirs" | "install" \
    | "upgrade")
    if [ ! -f $2 ]; then
      echo "$2 does not exist"
      exit 1
    fi
    ;;
esac

if [ $1 == "make" ]; then
  set -e
  if [ -n "$2" ]; then
    if [ ! $2 == "lib32" ]; then
      echo "unknown option $2"
      exit 1
    fi
  fi
  if [ ! -z ${vcs} ]; then
    if [ ${vcs} = 'git' ]; then
      if [ ! -z ${git_pkgname} ]; then
        git clone $SOURCES_HOME/${git_pkgname} ${srcdir}
      else
        git clone $SOURCES_HOME/${pkgname} ${srcdir}
      fi
      cd ${srcdir}
      git checkout ${gittag}
    fi
    if [ ${vcs} = 'mercurial' ]; then
      if [ ! -z ${hg_pkgname} ]; then
        hg clone $SOURCES_HOME/${hg_pkgname} ${srcdir}
      else
        hg clone $SOURCES_HOME/${pkgname} ${srcdir}
      fi
      cd ${srcdir}
      hg update -r ${hgtag}
    fi
  else
    if [[ ${srctar} ]]; then
      echo "unpacking ${srctar}..."
      tar xf ${srctar}
      if [[ ${srcdir} ]]; then
        cd ${srcdir}
      fi
    fi
  fi
  XORG_PREFIX="/usr"
  XORG_CONFIG="--prefix=$XORG_PREFIX \
    --sysconfdir=/etc \
    --localstatedir=/var \
    --disable-static"
  if [ "$2" == "lib32" ]; then
    pkgname=lib32-${pkgname}
    KIIN_LIB32=1
    export CC="gcc -m32"
    export CXX="g++ -m32"
    export PKG_CONFIG_PATH="/usr/lib32/pkgconfig"
    LIBDIR="/usr/lib32"
  else
    LIBDIR="/usr/lib"
  fi
  kiin_make 2>&1 | tee ${location}/kiin_make_log
  make_exit_status=${PIPESTATUS[0]}
  if [ ${make_exit_status} -gt 0 ]; then
    exit ${make_exit_status}
  fi

  maker=${location}/kiin_maker.sh
  cat > ${maker} << "EOF"
#!/bin/sh
set -e
cd ${location}
. ./package.sh
if [ -n "$KIIN_LIB32" ]; then
  pkgname=lib32-${pkgname}
fi
mkdir ${pkgdir}
if [[ ${srcdir} ]]; then
  cd ${srcdir}
fi
kiin_install 2>&1 | tee ${location}/kiin_install_log
install_exit_status=${PIPESTATUS[0]}
if [ ${install_exit_status} -gt 0 ]; then
  exit ${install_exit_status}
fi
fix_symlinks.py

# remove trash from lib32 version
if [ -n "$KIIN_LIB32" ]; then
  if [ "$pkgname" != "lib32-glibc" ]; then
    if [ "$pkgname" != "lib32-libpng" ]; then
      rm -rf "${pkgdir}"/{usr/{include,share,bin},etc}
    fi
  fi
fi

# fix /usr/share/info/dir
rm -fv ${pkgdir}/usr/share/info/dir
if [ -e ${pkgdir}/var ]; then
  echo " *** WARNING ***: package tries to use /var"
fi

# remove *.la files
if [ -d ${pkgdir}/lib ]; then
  find ${pkgdir}/lib -name "*.la" | xargs rm -vf
fi
if [ -d ${pkgdir}/usr/lib ]; then
  find ${pkgdir}/usr/lib -name "*.la" | xargs rm -vf
fi
if [ -d ${pkgdir}/usr/lib32 ]; then
  find ${pkgdir}/usr/lib32 -name "*.la" | xargs rm -vf
fi

cd ${location}
echo creating xz archive...
tar cfa kiin.${pkgname}-${pkgver}.tar.xz kiin-dest \
  package.sh \
  kiin_make_log \
  kiin_install_log
EOF
  chmod +x ${maker}
  location=${location} srcdir=${srcdir} pkgdir=${pkgdir} \
    pkgname=${pkgname} pkgver=${pkgver} KIIN_LIB32=${KIIN_LIB32} \
    XORG_PREFIX=${XORG_PREFIX} XORG_CONFIG=${XORG_CONFIG} \
    fakeroot ${maker}
  rm ${maker}
  rm ${location}/kiin_make_log
  rm ${location}/kiin_install_log
  rm -rf ${pkgdir}
  if [[ ${srcdir} ]]; then
    rm -rf ${srcdir}
  fi
  green='\e[0;32m'
  txtrst='\e[0m'
  printf "${green}kiin: all done!${txtrst}\n"
  exit 0
fi

if [ $1 = "download" ]; then
  for url in $urls; do
    if [[ $url == *midnight* ]]; then
      wget --no-check-certificate $url
    else
      wget $url
    fi
  done
  exit 0
fi

if [ $1 == 'gen-db' ]; then
  # add kiin-git-1 package
  tmpdir=/tmp/kiin-user/`uuidgen -t`
  mkdir -p $tmpdir
  cd $tmpdir
  git clone / kiin-dest 1>/dev/null
  rm -rf kiin-dest/.git
  find kiin-dest ! -type d | tar cfa kiin.kiin-git-1.tar.xz -T - --no-recursion
  mv kiin.kiin-git-1.tar.xz $KIIN_HOME/installed
  cd /tmp
  rm -rf $tmpdir
  # add kiin-known-1 package
  tmpdir=/tmp/kiin-user/`uuidgen -t`
  mkdir -p $tmpdir
  cd $tmpdir
  mkdir kiin-dest
  cd kiin-dest
  mkdir -p boot/grub/i386-pc
  mkdir -p etc/{ssh,gtk-2.0,xml,udev}
  mkdir -p usr/{share/info,lib/locale}
  mkdir -p usr/share/{icons/hicolor,glib-2.0/schemas,applications}
  mkdir -p usr/{lib/pango/1.8.0,lib/gdk-pixbuf-2.0/2.10.0}
  touch boot/grub/i386-pc/core.img
  touch boot/grub/grubenv
  touch etc/xml/docbook
  touch etc/xml/catalog
  touch etc/udev/hwdb.bin
  touch etc/group
  touch etc/gshadow-
  touch etc/shadow-
  touch etc/gshadow
  touch etc/passwd
  touch etc/shadow
  touch etc/.pwd.lock
  touch etc/ssh/ssh_host_key.pub
  touch etc/ssh/ssh_host_dsa_key
  touch etc/ssh/ssh_host_rsa_key.pub
  touch etc/ssh/ssh_host_key
  touch etc/ssh/ssh_host_dsa_key.pub
  touch etc/ssh/ssh_host_ecdsa_key.pub
  touch etc/ssh/ssh_host_rsa_key
  touch etc/ssh/ssh_host_ecdsa_key
  touch etc/passwd-
  touch etc/group-
  touch usr/share/info/dir
  touch usr/lib/locale/locale-archive
  touch usr/lib/pango/1.8.0/modules.cache
  touch usr/lib/gdk-pixbuf-2.0/2.10.0/loaders.cache
  touch etc/gtk-2.0/gtk.immodules
  touch usr/share/icons/hicolor/icon-theme.cache
  touch usr/share/glib-2.0/schemas/gschemas.compiled
  touch usr/share/applications/mimeinfo.cache
  touch etc/mtab.fuselock
  touch etc/machine-id
  cd ..
  find kiin-dest ! -type d | tar cfa kiin.kiin-known-1.tar.xz -T - --no-recursion
  mv kiin.kiin-known-1.tar.xz $KIIN_HOME/installed
  cd /tmp
  rm -rf $tmpdir
  # generate db
  for i in `db_manager.py gen-db | sort | uniq | grep -v kiin-known \
    | grep -v kiin-git`; do
    kiin update-links $i
  done
  exit 0
fi

if [ $1 == 'list-dups' ]; then
  echo "select * from (select count(id) as cnt, name from file \
    where permissions not like 'd%' group by name \
    order by cnt desc) where cnt > 1;" | sqlite3 $KIIN_DB \
    | sed 's/|/\ \ /g'
  exit 0
fi

if [ $1 == 'who-owns' ]; then
  echo "select name,version from package where id in \
    (select distinct package_id from file where name = '$2' \
    and permissions not like 'd%');" | sqlite3 $KIIN_DB \
    | sed 's/|/\-/g' | sort
  exit 0
fi

if [ $1 == 'who-uses-dir' ]; then
  dir=`echo $2 | sed 's/\/$//g'`
  echo "select name,version from package where id in \
    (select distinct package_id from file where name = '$dir/' \
    and permissions like 'd%');" | sqlite3 $KIIN_DB \
    | sed 's/|/\-/g' | sort
  exit 0
fi

if [ $1 == 'check-conflicts' ]; then
  for i in `kiin list-files $2`; do
    if [ -e $i ]; then
      echo $i already exists on filesystem
    fi
  done
  for i in `kiin list-dirs $2`; do
    i=`echo $i | sed 's/\/$//g'`
    if [ -e $i ]; then
      if [ ! -d $i ]; then
        echo "$i already exists on filesystem and is not a dir"
      fi
    fi
  done
  exit 0
fi

if [ $1 == 'list-files' ]; then
  tar -tvf $2 | tr -s ' ' | grep -E '^[-lpscbh].*' | cut -d ' ' --fields=6 | grep '^kiin-dest' | sed 's/kiin-dest//g' | sort
  exit 0
fi

if [ $1 == 'list-dirs' ]; then
  tar -tvf $2 | tr -s ' ' | grep -E '^d.*' | cut -d ' ' --fields=6 | grep '^kiin-dest' | sed 's/kiin-dest//g' | sort
  exit 0
fi

if [ $1 == 'install' ]; then
  package=`echo $(basename $2) | sed 's/kiin\.//g' | sed 's/\.tar\.xz//g' | sed 's/-[^-]*$//g'`
  if [ `echo "select id from package where name='${package}';" | sqlite3 $KIIN_DB | wc -l` -gt 0 ]; then
    echo "Package with name $package is already installed. Aborting."
    exit 1
  fi
  if [ `kiin list-dups | wc -l` != '0' ]; then
    echo "where are duplicates in the system, not installing"
    exit 1
  fi
  if [ `kiin check-conflicts $2 | wc -l` != '0' ]; then
    echo "where are conflicts, not installing"
    exit 1
  fi
  startdir=`pwd`
  tmpdir=/tmp/kiin/`uuidgen -t`
  mkdir -p $tmpdir
  tar xf $2 -C $tmpdir
  for dir in `kiin list-dirs $2`; do
    if [ ! -d $dir ]; then
      prototype=$tmpdir/kiin-dest$dir
      mkdir -pv $dir
      chmod `stat -c %a $prototype` $dir
      #echo "chown `stat -c %U $prototype`:`stat -c %G $prototype` $dir"
    fi
  done
  for file in `kiin list-files $2`; do
    prototype=$tmpdir/kiin-dest$file
    cp -av $prototype $file
  done
  if [ -d $tmpdir/kiin-dest/usr/share/info ]; then
    recreate_info_dir
  fi
  cd $startdir
  sudo -u $PACKAGE_MANAGER mv -v $2 $KIIN_HOME/installed
  sudo -u $PACKAGE_MANAGER kiin gen-db
  if [ -f $tmpdir/package.sh ]; then
    grep -q "kiin_after_install" $tmpdir/package.sh
    if [ $? -eq 0 ]; then
      echo "running kiin_after_install..."
      . $tmpdir/package.sh
      kiin_after_install
    fi
  fi
  rm -rf $tmpdir
  echo "running ldconfig..."
  ldconfig
  exit 0
fi

if [ $1 == 'upgrade' ]; then
  if [ `kiin list-dups | wc -l` != '0' ]; then
    echo "where are duplicates in the system, not upgrading"
    exit 1
  fi
  package=`echo $(basename $2) | sed 's/kiin\.//g' | sed 's/\.tar\.xz//g' | sed 's/-[^-]*$//g'`
  check_system_packages $package $1
  new_version=`echo $(basename $2) | sed 's/kiin\.//g' | sed 's/\.tar\.xz//g' | sed "s/$package-//g"`
  old_version=`echo "select version from package where name='$package';" \
    | sqlite3 $KIIN_DB`
  if [ -z $old_version ]; then
    echo "no such package installed, sorry"
    exit 1
  fi
  startdir=`pwd`
  echo "upgrading $package from $old_version to $new_version"
  # remount /boot partition in rw mode
  case $package in
    "linux" | "grub" | "initramfs")
      mount -o remount,rw /boot
      ;;
  esac
  tmpdir=/tmp/kiin/`uuidgen -t`
  mkdir -p $tmpdir
  tar xf $2 -C $tmpdir
  for i in `kiin list-files $2`; do
    owners=`kiin who-owns $i`
    owner_count=`echo $owners | wc -w`
    [[ $owner_count = 0 ]] && [[ -e $i ]] && {
      echo "$i has no owners: $owners, but exists on filesystem, not upgrading"
      exit 1
    }
    [[ $owner_count > 0 ]] && [[ $owners != "$package-$old_version" ]] && {
      echo "$i has following owners: $owners, not upgrading"
      exit 1
    }
  done
  for i in `kiin list-dirs $2`; do
    i=`echo $i | sed 's/\/$//g'`
    if [ -e $i ]; then
      if [ ! -d $i ]; then
        echo "$i already exists on filesystem and is not a dir, not upgrading"
        exit 1
      fi
    fi
  done
  if [ ! "$3" = 'noask' ]; then
    echo "Following processes are using $package-$old_version right now, JFYI:"
    kiin who-uses-now $package-$old_version
    echo "Following files are going to be deleted:"
    for file in `kiin db-list-files $package-$old_version`; do
      if [ ! -e $tmpdir/kiin-dest$file ]; then
        if [ ! -h $tmpdir/kiin-dest$file ]; then
          echo $file
        fi
      fi
    done
    read -p "Are you sure? (y/N)" answer
    case $answer in
      [Yy]* ) echo "let's go";;
      * ) echo "Answer was not y/Y, exiting."; exit 1;;
    esac
  fi
  # actual destructive shit
  # TODO: remove broken symbolic links to prevent
  # 'too many levels of symbolic links' error later

  # create new dirs
  for dir in `kiin list-dirs $2`; do
    if [ ! -d $dir ]; then
      prototype=$tmpdir/kiin-dest$dir
      mkdir -pv $dir
      chmod -v `stat -c %a $prototype` $dir
    fi
  done
  # copy new files
  for file in `kiin list-files $2`; do
    prototype=$tmpdir/kiin-dest$file
    if [ ! -e $file ]; then
      if [ ! -h $file ]; then
        cp -avf $prototype $file
      fi
    fi
  done
  # overwrite updated files
  for file in `kiin list-files $2`; do
    prototype=$tmpdir/kiin-dest$file
    # symlinks to folders: delete before "overwriting"
    if [ -h $file ]; then
      if [ -d $file ]; then
        rm -vf $file
      fi
    fi
    # the only place with overwriting
    cp -avf $prototype ${file}.kiin
    $KIIN_HOME/_kiin-rename ${file}.kiin $file
  done
  # remove old files
  for file in `kiin db-list-files $package-$old_version`; do
    if [ ! -e $tmpdir/kiin-dest$file ]; then
      if [ ! -h $tmpdir/kiin-dest$file ]; then
        rm -v $file
      fi
    fi
  done
  # remove old dirs
  for dir in `kiin db-list-dirs $package-$old_version \
    | awk '{ print length, $0 }' | sort -n -r | cut -d " " --fields=2`; do
    users=`kiin who-uses-dir $dir`
    user_count=`echo $users | wc -w`
    [[ $user_count = 1 ]] && [[ $users = "$package-$old_version" ]] && [[ ! -d $tmpdir/kiin-dest$dir ]] && {
      filecnt=`ls $dir | wc -w`
      if [ $filecnt -eq 0 ]; then
        rm -rv $dir
      fi
    }
  done
  if [ -d $tmpdir/kiin-dest/usr/share/info ]; then
    recreate_info_dir
  fi
  cd $startdir
  sudo -u $PACKAGE_MANAGER mv -v $KIIN_HOME/installed/kiin.$package-$old_version.tar.xz \
    $KIIN_HOME/uninstalled
  sudo -u $PACKAGE_MANAGER mv -v $2 $KIIN_HOME/installed
  sudo -u $PACKAGE_MANAGER kiin gen-db
  # update hashsums for /boot partition
  case $package in
    "linux" | "grub" | "initramfs")
      echo "updating /boot hashsums..."
      sync
      mount -o remount,ro /boot
      md5sum -b /dev/sda2 > /root/boot_md5
      sha1sum -b /dev/sda2 > /root/boot_sha1
      ;;
  esac
  if [ -f $tmpdir/package.sh ]; then
    grep -q "kiin_after_upgrade" $tmpdir/package.sh
    if [ $? -eq 0 ]; then
      echo "running kiin_after_upgrade..."
      . $tmpdir/package.sh
      kiin_after_upgrade
    fi
  fi
  rm -rf $tmpdir
  echo "running ldconfig..."
  ldconfig
  exit 0
fi

if [ $1 == 'ls' ]; then
  echo "select name,version from package;" \
    | sqlite3 $KIIN_DB \
    | sed 's/|/\-/g' | sort -R
  exit 0
fi

if [ $1 == 'uninstall' ]; then
  if [ `kiin list-dups | wc -l` != '0' ]; then
    echo "where are duplicates in the system, not uninstalling"
    exit 1
  fi
  package_only=`echo $package | sed 's/-[^-]*$//g'`
  check_system_packages $package_only $1
  dependent=`kiin linked-by $package`
  linked_by_count=`echo $dependent | wc -w`
  if [ $linked_by_count -gt 0 ]; then
    echo "$package is linked by following packages: $dependent"
    echo "won't uninstall, bro."
    exit 1
  fi
  mkdir -p /tmp/kiin
  for file in `kiin db-list-files $package`; do
    rm -v $file
  done
  do_recreate_info_dir=0
  for dir in `kiin db-list-dirs $package \
    | awk '{ print length, $0 }' | sort -n -r | cut -d " " --fields=2`; do
    if [ $dir == "/usr/share/info/" ]; then
      do_recreate_info_dir=1
    fi
    users=`kiin who-uses-dir $dir`
    user_count=`echo $users | wc -w`
    [[ $user_count = 1 ]] && [[ $users = $package ]] && {
      filecnt=`ls $dir | wc -w`
      if [ $filecnt -eq 0 ]; then
        rm -rv $dir
      fi
    }
  done
  if [ $do_recreate_info_dir -eq 1 ]; then
    recreate_info_dir
  fi
  sudo -u $PACKAGE_MANAGER mv -v $KIIN_HOME/installed/kiin.$package.tar.xz \
    $KIIN_HOME/uninstalled
  sudo -u $PACKAGE_MANAGER kiin gen-db
  echo "running ldconfig..."
  ldconfig
  exit 0
fi

if [ $1 == 'db-list-files' ]; then
  package=`echo $package | sed 's/\-[^-]*$//g'`
  echo "select name from file where package_id in \
    (select id from package where name='$package') \
    and permissions not like 'd%';" \
    | sqlite3 $KIIN_DB | sort
  exit 0
fi

if [ $1 == 'db-list-dirs' ]; then
  package=`echo $package | sed 's/\-[^-]*$//g'`
  echo "select name from file where package_id in \
    (select id from package where name='$package') \
    and permissions like 'd%';" \
    | sqlite3 $KIIN_DB | sort
  exit 0
fi

if [ $1 == 'list-untracked' ]; then
  if [ ! -d $2 ]; then
    echo "dir $2 does not exist"
    exit 1
  fi
  dir=`echo $2 | sed 's/\/$//g'`
  find $dir ! -type d | db_manager.py list-untracked
  exit 0
fi

if [ $1 == 'check-system-integrity' ]; then
  dirs=
  for i in `ls /`; do
    if [ ! -z "`kiin who-uses-dir /$i | grep -v filesystem`" ]; then
      dirs="$dirs /$i"
    fi
  done
  echo " * searching for untracked files on filesystem..."
  echo " * used system dirs:" $dirs
  for i in $dirs; do
    kiin list-untracked $i
  done
  echo " * searching for missing package files..."
  kiin list-missing
  echo " * searching for duplications in package db..."
  kiin list-dups
  exit 0
fi

if [ $1 == 'list-missing' ]; then
  for package in `kiin ls`; do
    for file in `kiin db-list-files $package`; do
      if [ ! -e $file ]; then
        echo "$file is missing ($package)"
      fi
    done
  done
  exit 0
fi

vercomp() {
  if [[ $1 == $2 ]]; then
    return 0
  fi
  BIGGER=`echo -e "$1\n$2" | sort -V | head -n 1`
  if [[ $BIGGER == $1 ]]; then
    return 2
  fi
  return 1
}

if [ $1 == 'prepare-check-updates' ]; then
  cd $ARCH_PACKAGES_REPO
  git pull
  git fetch -p
  cd $ARCH_COMMUNITY_REPO
  git pull
  git fetch -p
  cd $SOURCES_HOME/linux
  git pull
  git fetch -p
  exit 0
fi

if [ $1 == 'check-updates' ]; then
  bldred='\e[1;31m'
  green='\e[0;32m'
  txtrst='\e[0m'
  #echo "checking git repos"
  package=linux
  cd $SOURCES_HOME/$package
  newest_tag=`git for-each-ref --sort='*authordate' --format='%(tag)' refs/tags | tail -n 1`
  pkgver=`echo $newest_tag | sed 's/^v//g' | sed 's/-/\./g'`
  version=`echo "select version from package where name='${package}';" | sqlite3 $KIIN_DB`
  vercomp `echo "$pkgver" | sed 's/rc/0\./g'` `echo "$version" | sed 's/rc/0\./g'`
  cmp=$?
  if [ $cmp -ne 0 ]; then
    printf "${bldred}%20s${txtrst} %15s %12s (tag $newest_tag)\n" \
      "${package}" "${version}" "${pkgver}"
  fi
  #echo "checking arch linux updates"
  for i in `kiin ls | sort`; do
    package=`echo $i | sed 's/\-[^-]*$//g'`
    version=`echo $i | sed "s/$package-//g"`
    local_package=$package
    # package name exceptions:
    [[ $package = 'python' ]] && package='python2'
    [[ $package = 'python2-virtualenv' ]] && package='python-virtualenv'
    [[ $package = 'python2-gobject2' ]] && package='pygobject2'
    [[ $package = 'python2-gtk' ]] && package='pygtk'
    [[ $package = 'python2-openssl' ]] && package='pyopenssl'
    [[ $package = 'python2-pyasn1' ]] && package='python-pyasn1'
    [[ $package = 'python2-crypto' ]] && package='pycrypto'
    [[ $package = 'mpc' ]] && package='libmpc'
    [[ $package = 'udev' ]] && package='systemd'
    [[ $package = 'glib' ]] && package='glib2'
    [[ $package = 'gdk-pixbuf' ]] && package='gdk-pixbuf2'
    [[ $package = 'mpd-mpc' ]] && package='mpc'
    [[ $package = 'device-mapper' ]] && package='lvm2'
    [[ $package = 'perl-ack' ]] && package='ack'
    [[ $package = 'lzo' ]] && package='lzo2'
    [[ $package = 'lib32-libtool' ]] && package='libtool-multilib'
    [[ $package = 'ntfsprogs' ]] && package='ntfs-3g_ntfsprogs'
    [[ $package = 'lib32-freeglut' ]] && package='freeglut'
    [[ $package = 'djview' ]] && package='djview4'
    [[ $package = 'procps' ]] && package='procps-ng'
    # package version exceptions:
    [[ $package = 'readline' ]] && [[ $version = '6.2' ]] && version='6.2.004'
    [[ $package = 'mpfr' ]] && [[ $version = '3.1.1' ]] && version='3.1.1.p2'
    [[ $package = 'sysvinit' ]] && [[ $version = '2.88dsf' ]] && version='2.88'
    [[ $package = 'openssl' ]] && [[ $version = '1.0.1e' ]] && version='1.0.1.e'
    [[ $package = 'sudo' ]] && [[ $version = '1.8.6p6' ]] && version='1.8.6.p6'
    [[ $package = 'nss' ]] && [[ $version = '3.14.1' ]] && version='3.14.1.1.93'
    # not found in Arch:
    [[ $package = 'vlock' ]] && continue
    [[ $package = 'sysklogd' ]] && continue
    [[ $package = 'xorg-makedepend' ]] && continue
    [[ $package = 'libpthread-stubs' ]] && continue
    [[ $package = 'python2-sh' ]] && continue
    [[ $package = 'libjpeg' ]] && continue
    [[ $package = 'sdl2' ]] && continue
    [[ $package = 'lib32-sdl2' ]] && continue
    # won't upgrade:
    [[ $package = 'linux' ]] && continue # we use and check git version
    [[ $package = 'gnupg' ]] && continue # we read gnupg-announce@
    [[ $package = 'evince' ]] && continue # evince2 is the only option
    [[ $package = 'initramfs' ]] && continue
    [[ $package = 'filesystem' ]] && continue
    [[ $package = 'linux-firmware' ]] && continue
    [[ $package = 'cacerts' ]] && continue
    [[ $package = 'kiin-git' ]] && continue
    [[ $package = 'kiin-known' ]] && continue

    _package=""
    if [ $package != $local_package ]; then
      _package=" ($package)"
    fi

    if [ -d $ARCH_PACKAGES_REPO/$package ]; then
      . $ARCH_PACKAGES_REPO/$package/trunk/PKGBUILD
      vercomp "$pkgver" "$version"
      cmp=$?
      if [ $cmp -ne 0 ]; then
        if [ $cmp -eq 2 ]; then
          if [ "$2" == 'diff' ]; then
            printf "${green}%20s${txtrst} %15s %12s%s\n" \
              "${local_package}" "${version}" "${pkgver}" "${_package}"
          fi
        else
          printf "${bldred}%20s${txtrst} %15s %12s%s\n" \
            "${local_package}" "${version}" "${pkgver}" "${_package}"
        fi
      fi
    else
      if [ -d $ARCH_COMMUNITY_REPO/$package ]; then
        . $ARCH_COMMUNITY_REPO/$package/trunk/PKGBUILD
        vercomp "$pkgver" "$version"
        cmp=$?
        if [ $cmp -ne 0 ]; then
          if [ $cmp -eq 2 ]; then
            if [ "$2" == 'diff' ]; then
              printf "${green}%20s${txtrst} %15s %12s%s\n" \
                "${local_package}" "${version}" "${pkgver}" "${_package}"
            fi
          else
            printf "${bldred}%20s${txtrst} %15s %12s%s\n" \
              "${local_package}" "${version}" "${pkgver}" "${_package}"
          fi
        fi
      else
        echo "  cannot find $package in arch packages"
      fi
    fi
  done

  exit 0
fi

if [ $1 == 'update-links' ]; then
  package_name=`echo $package | sed 's/\-[^-]*$//g'`
  echo "updating links for $package_name..."
  user_package_id=`echo "select id from package where name='$package_name';" \
      | sqlite3 $KIIN_DB`
  echo "delete from depends where user_id=$user_package_id;" \
    | sqlite3 $KIIN_DB
  for i in `kiin db-list-files $package`; do
    if [ ! -r $i ]; then
      ldd_invocator='sudo ldd'
    else
      ldd_invocator='ldd'
    fi
    for j in `$ldd_invocator 2>/dev/null $i | grep -v "not a dynamic executable" \
        | sed 's/\ (0x.*$//g' | sed 's/^.*\ =>\ //g' \
        | sed 's/^[ \t]*//g' | grep -v "linux-vdso.so.1"`; do
      echo `readlink -m $j`
    done
  done | sed 's/\/lib64/\/lib/g' | sed 's/\/usr\/lib64/\/usr\/lib/g' \
    | sort | uniq | while read line; do
    kiin who-owns $line
  done | sort | uniq | while read dep_package; do
    dep_package_name=`echo $dep_package | sed 's/\-[^-]*$//g'`
    dep_package_id=`echo "select id from package where name='$dep_package_name';" \
       | sqlite3 $KIIN_DB`
    echo "insert into depends(user_id,provider_id) values \
      ($user_package_id, $dep_package_id);" \
      | sqlite3 $KIIN_DB
  done
  exit 0
fi

if [ $1 == 'links' ]; then
  package_name=`echo $package | sed 's/\-[^-]*$//g'`
  echo "select package.name from (select * from package join depends \
    on package.id=depends.user_id where name='$package_name') dep join package on \
    dep.provider_id=package.id where user_id <> provider_id;" \
    | sqlite3 $KIIN_DB
  exit 0
fi

if [ $1 == 'linked-by' ]; then
  package_name=`echo $package | sed 's/\-[^-]*$//g'`
  echo "select package.name from (select * from package join depends \
    on package.id=depends.provider_id where name='$package_name') dep join package on \
    dep.user_id=package.id where user_id <> provider_id;" \
    | sqlite3 $KIIN_DB
  exit 0
fi

if [ $1 == 'l' ]; then
  kiin links $package | sort && echo "---" && kiin linked-by $package | sort
  exit 0
fi

if [ $1 == 'who-uses-now' ]; then
  for f in `kiin db-list-files $package`; do lsof $f; done \
    | grep -v COMMAND | tr -s ' ' | cut -d ' ' --fields=1,2,3 \
    | sort | uniq
  exit 0
fi

if [ $1 == 'check-buildorder' ]; then
  for i in `kiin ls`; do
    package=`echo $i | sed 's/\-[^-]*$//g'`
    grep -q $package $KIIN_HOME/buildorder
    if [ $? -gt 0 ]; then
      echo "$package is missing from buildorder"
    fi
  done
  for i in `cat $KIIN_HOME/buildorder`; do
    count=`echo "select * from package where name='$i';" | sqlite3 $KIIN_DB | wc -l`
    if [ $count -lt 1 ]; then
      echo "$i is not installed, but is in buildorder"
    fi
  done
  dups=`cat $KIIN_HOME/buildorder | sort | uniq -d`
  if [ ! -z $dups ]; then
    echo "duplicates in buildorder: $dups"
  fi
  echo "order offenders:"
  for i in `kiin ls`; do
    package=`echo $i | sed 's/\-[^-]*$//g'`
    order=`grep -n "^$package$" $KIIN_HOME/buildorder | cut -d ":" --fields 1`
    offending=""
    for j in `kiin links $i`; do
      dep_order=`grep -n "^$j$" $KIIN_HOME/buildorder | cut -d ":" --fields 1`
      if [ $dep_order -gt $order ]; then
        offending="$offending $j"
      fi
    done
    if [ ! -z "$offending" ]; then
      echo $package
      echo "    $offending"
    fi
  done
  exit 0
fi

if [ $1 == 'rebuild-world' ]; then
  set -e
  date > /tmp/kiin-rebuild-world
  packages=`cat $KIIN_HOME/buildorder`
  if [ -n "$2" ]; then
    packages=`cat $KIIN_HOME/buildorder | grep -A 1000 "^$2$"`
  fi
  if [ -n "$3" ]; then
    packages=`cat $KIIN_HOME/buildorder | grep -A 1000 "^$2$" | grep -B 1000 "^$3$"`
  fi
  for package in $packages; do
    # won't upgrade (never installed them in the first place)
    [[ $package = 'filesystem' ]] && continue
    [[ $package = 'kiin-git' ]] && continue
    [[ $package = 'kiin-known' ]] && continue

    # upgrade only manually
    [[ $package = 'cacerts' ]] && continue # needs internet access
    [[ $package = 'initramfs' ]] && continue # needs sudo password to build

    lib32=0
    lib32test=`echo $package | grep lib32 | wc -w`
    if [ $lib32test -gt 0 ]; then
      package=`echo $package | sed 's/lib32\-//g'`
      lib32=1
    fi
    echo "rebuilding $package (lib32=$lib32)"
    for package_dir in `kiin list-package-dirs`; do
      found=`find $KIIN_HOME/${package_dir} -type d -name $package`
      if [ -n "$found" ]; then
        break
      fi
    done
    cd $found
    if [ $lib32 -eq 0 ]; then
      kiin make
    else
      kiin make lib32
    fi
    for pack in `find . -name 'kiin.*xz'`; do
      sudo kiin upgrade $pack noask
    done
  done
  date >> /tmp/kiin-rebuild-world
  exit 0
fi

if [ $1 == 'convert-arch-package' ]; then
  echo "converting arch package..."
  if [ -f ${location}/${arch_tar} ]; then
    echo "${arch_tar} present"
  else
    wget ${arch_url}
  fi
  converter=${location}/kiin_converter.sh
  cat > ${converter} << "EOF"
#!/bin/sh
cd ${location}
. ./package.sh
mkdir ${pkgdir}
tar xvf ${arch_tar} -C ${pkgdir}
rm ${pkgdir}/.PKGINFO
rm ${pkgdir}/.INSTALL

# fix /usr/share/info/dir
rm -fv ${pkgdir}/usr/share/info/dir
if [ -e ${pkgdir}/var ]; then
  echo " *** WARNING ***: package tries to use /var"
fi

# remove *.la files
if [ -d ${pkgdir}/lib ]; then
  find ${pkgdir}/lib -name "*.la" | xargs rm -vf
fi
if [ -d ${pkgdir}/usr/lib ]; then
  find ${pkgdir}/usr/lib -name "*.la" | xargs rm -vf
fi
if [ -d ${pkgdir}/usr/lib32 ]; then
  find ${pkgdir}/usr/lib32 -name "*.la" | xargs rm -vf
fi

rm -rf ${pkgdir}/usr/share/licenses

if [ ${pkgname} == 'lib32-glibc' ]; then
  mkdir ${pkgdir}/lib
  ln -sv /usr/lib32/ld-linux.so.2 ${pkgdir}/lib/ld-linux.so.2
fi

cd ${location}
echo creating xz archive...
tar cfa kiin.${pkgname}-${pkgver}.tar.xz kiin-dest
EOF
  chmod +x ${converter}
  location=${location} srcdir=${srcdir} pkgdir=${pkgdir} \
    pkgname=${pkgname} pkgver=${pkgver} fakeroot ${converter}
  rm ${converter}
  rm -rf ${pkgdir}
  echo "done."
  exit 0
fi

if [ $1 == 'list-package-dirs' ]; then
  echo 'base security dev essentials gui multimedia perl-modules python2-modules xorg mail skype'
  exit 0
fi

usage
