#!/bin/bash

KIIN_HOME=/var/kiin
KIIN_DB=$KIIN_HOME/kiin-db/kiin.sqlite3

usage() {
  echo "usage:"
  echo "  kiin make [lib32]"
  echo "  kiin download"
  echo "  kiin gen-db"
  echo "  kiin list-dups"
  echo "  kiin who-owns </full/path/to/file>"
  echo "  kiin who-uses-dir </full/path/to/dir>"
  echo "  kiin check-conflicts </path/to/package.xz>"
  echo "  kiin list-files </path/to/package.xz>"
  echo "  kiin list-dirs </path/to/package.xz>"
  echo "  kiin install </path/to/package.xz>"
  echo "  kiin upgrade </path/to/package.xz> [noask]"
  echo "  kiin ls"
  echo "  kiin uninstall <package>"
  echo "  kiin db-list-files <package>"
  echo "  kiin db-list-dirs <package>"
  echo "  kiin list-untracked <dir>"
  echo "  kiin check-system-integrity"
  echo "  kiin list-missing"
  echo "  kiin prepare-check-updates"
  echo "  kiin check-updates"
  echo "  kiin update-links <package>"
  echo "  kiin links <package>"
  echo "  kiin linked-by <package>"
  echo "  kiin l <package>"
  echo "  kiin check-buildorder"
  echo "  kiin rebuild-world"
  echo "  kiin backup"
  echo "  kiin convert-arch-package"
}

# for upgrade and uninstall
check_system_packages() {
  case $1 in
    "kiin-git" | "kiin-known" | "filesystem" | "glibc")
      echo "wouldn't want to $2 $1, would ya?"
      exit 1
      ;;
  esac
}

# for upgrade, install and uninstall
recreate_info_dir() {
  cd /usr/share/info
  rm -v dir
  for f in *; do
    install-info $f dir 2>/dev/null
  done
}

if [ -z $1 ]; then
  usage
  exit 0
fi

case $1 in
  "make" | "download" | "convert-arch-package")
    if [ ! -f ./package.sh ]; then
      echo "no package.sh found, goodbye."
      exit 1
    fi
    location=`pwd`
    . ./package.sh

    pkgdir=${location}/kiin-dest
    ;;
esac
case $1 in
  "install" | "upgrade" | "uninstall" | "list-untracked" \
    | "check-system-integrity" | "list-missing" | "backup")
    if [ `whoami` != 'root' ]; then
      echo "you must be root to run kiin $1"
      exit 1
    fi
    ;;
esac
case $1 in
  "who-owns" | "who-uses-dir" | "check-conflicts" | "list-files" \
    | "list-dirs" | "install" | "upgrade" | "uninstall" | "db-list-files" \
    | "db-list-dirs" | "list-untracked" | "update-links" | "links" \
    | "linked-by" | "l")
    if [ -z $2 ]; then
      echo "usage:" && usage | grep $1
      exit 1
    fi
    ;;
esac
case $1 in
  "uninstall" | "db-list-files" | "db-list-dirs" | "update-links" \
    | "links" | "linked-by" | "l")
    count=`kiin ls | grep "^$2" | wc -l`
    if [ $count = 0 ]; then
      echo "$2 is not installed"
      exit 1
    fi
    if [ $count -gt 1 ]; then
      echo "$2 is ambiguous (" `kiin ls | grep "^$2"` ")"
      exit 1
    fi
    package=`kiin ls | grep "^$2"`
    ;;
esac
case $1 in
  "check-conflicts" | "list-files" | "list-dirs" | "install" \
    | "upgrade")
    if [ ! -f $2 ]; then
      echo "$2 does not exist"
      exit 1
    fi
    ;;
esac

if [ $1 == "make" ]; then
  set -e
  if [ -n "$2" ]; then
    if [ ! $2 == "lib32" ]; then
      echo "unknown option $2"
      exit 1
    fi
  fi
  if [ ! -z ${vcs} ]; then
    if [ ${vcs} = 'git' ]; then
      if [ ! -z ${git_pkgname} ]; then
        git clone $KIIN_HOME/src/${git_pkgname} ${srcdir}
      else
        git clone $KIIN_HOME/src/${pkgname} ${srcdir}
      fi
      cd ${srcdir}
      git checkout ${gittag}
    fi
    if [ ${vcs} = 'mercurial' ]; then
      if [ ! -z ${hg_pkgname} ]; then
        hg clone $KIIN_HOME/src/${hg_pkgname} ${srcdir}
      else
        hg clone $KIIN_HOME/src/${pkgname} ${srcdir}
      fi
      cd ${srcdir}
      hg update -r ${hgtag}
    fi
  else
    if [[ ${srctar} ]]; then
      echo "unpacking ${srctar}..."
      tar xf ${srctar}
      if [[ ${srcdir} ]]; then
        cd ${srcdir}
      fi
    fi
  fi
  if [ "$2" == "lib32" ]; then
    pkgname=lib32-${pkgname}
    KIIN_LIB32=1
  fi
  kiin_make

  maker=${location}/kiin_maker.sh
  cat > ${maker} << "EOF"
#!/bin/sh
cd ${location}
. ./package.sh
if [ -n "$KIIN_LIB32" ]; then
  pkgname=lib32-${pkgname}
fi
mkdir ${pkgdir}
if [[ ${srcdir} ]]; then
  cd ${srcdir}
fi
kiin_install
fix_symlinks.py

# fix /usr/share/info/dir
rm -fv ${pkgdir}/usr/share/info/dir
if [ -e ${pkgdir}/var ]; then
  echo " *** WARNING ***: package tries to use /var"
fi

# remove *.la files
if [ -d ${pkgdir}/lib ]; then
  find ${pkgdir}/lib -name "*.la" | xargs rm -vf
fi
if [ -d ${pkgdir}/usr/lib ]; then
  find ${pkgdir}/usr/lib -name "*.la" | xargs rm -vf
fi
if [ -d ${pkgdir}/usr/lib32 ]; then
  find ${pkgdir}/usr/lib32 -name "*.la" | xargs rm -vf
fi

cd ${location}
echo creating xz archive...
tar cfa kiin.${pkgname}-${pkgver}.tar.xz kiin-dest
EOF
  chmod +x ${maker}
  location=${location} srcdir=${srcdir} pkgdir=${pkgdir} \
    pkgname=${pkgname} pkgver=${pkgver} KIIN_LIB32=${KIIN_LIB32} \
    fakeroot ${maker}
  rm ${maker}
  rm -rf ${pkgdir}
  if [[ ${srcdir} ]]; then
    rm -rf ${srcdir}
  fi
  echo "kiin: all done!"
  exit 0
fi

if [ $1 = "download" ]; then
  for url in $urls; do
    if [[ $url == *midnight* ]]; then
      wget --no-check-certificate $url
    else
      wget $url
    fi
  done
  exit 0
fi

if [ $1 == 'gen-db' ]; then
  # add kiin-git-1 package
  tmpdir=/tmp/kiin-user/`uuidgen`
  mkdir -p $tmpdir
  cd $tmpdir
  git clone / kiin-dest 1>/dev/null
  rm -rf kiin-dest/.git
  tar cfa kiin.kiin-git-1.tar.xz kiin-dest
  mv kiin.kiin-git-1.tar.xz $KIIN_HOME/installed
  # add kiin-known-1 package
  tmpdir=/tmp/kiin-user/`uuidgen`
  mkdir -p $tmpdir
  cd $tmpdir
  mkdir kiin-dest
  cd kiin-dest
  mkdir -p boot/grub/i386-pc
  mkdir -p etc/{ssh,gtk-2.0,xml}
  mkdir -p usr/{share/info,lib/locale}
  mkdir -p usr/{lib/pango/1.8.0,lib/gdk-pixbuf-2.0/2.10.0}
  touch boot/grub/i386-pc/core.img
  touch boot/grub/grubenv
  touch etc/xml/docbook
  touch etc/xml/catalog
  touch etc/group
  touch etc/gshadow-
  touch etc/shadow-
  touch etc/gshadow
  touch etc/passwd
  touch etc/shadow
  touch etc/.pwd.lock
  touch etc/ssh/ssh_host_key.pub
  touch etc/ssh/ssh_host_dsa_key
  touch etc/ssh/ssh_host_rsa_key.pub
  touch etc/ssh/ssh_host_key
  touch etc/ssh/ssh_host_dsa_key.pub
  touch etc/ssh/ssh_host_ecdsa_key.pub
  touch etc/ssh/ssh_host_rsa_key
  touch etc/ssh/ssh_host_ecdsa_key
  touch etc/passwd-
  touch etc/group-
  touch usr/share/info/dir
  touch usr/lib/locale/locale-archive
  touch usr/lib/pango/1.8.0/modules.cache
  touch usr/lib/gdk-pixbuf-2.0/2.10.0/loaders.cache
  touch etc/gtk-2.0/gtk.immodules
  touch etc/mtab.fuselock
  cd ..
  tar cfa kiin.kiin-known-1.tar.xz kiin-dest
  mv kiin.kiin-known-1.tar.xz $KIIN_HOME/installed
  # generate db
  for i in `db_manager.py gen-db | sort | uniq | grep -v kiin-known \
    | grep -v kiin-git`; do
    kiin update-links $i
  done
  exit 0
fi

if [ $1 == 'list-dups' ]; then
  echo "select * from (select count(id) as cnt, name from file \
    where permissions not like 'd%' group by name \
    order by cnt desc) where cnt > 1;" | sqlite3 $KIIN_DB \
    | sed 's/|/\ \ /g'
  exit 0
fi

if [ $1 == 'who-owns' ]; then
  echo "select name,version from package where id in \
    (select distinct package_id from file where name = '$2' \
    and permissions not like 'd%');" | sqlite3 $KIIN_DB \
    | sed 's/|/\-/g' | sort
  exit 0
fi

if [ $1 == 'who-uses-dir' ]; then
  dir=`echo $2 | sed 's/\/$//g'`
  echo "select name,version from package where id in \
    (select distinct package_id from file where name = '$dir/' \
    and permissions like 'd%');" | sqlite3 $KIIN_DB \
    | sed 's/|/\-/g' | sort
  exit 0
fi

if [ $1 == 'check-conflicts' ]; then
  for i in `kiin list-files $2`; do
    if [ -e $i ]; then
      echo $i already exists on filesystem
    fi
  done
  for i in `kiin list-dirs $2`; do
    i=`echo $i | sed 's/\/$//g'`
    if [ -e $i ]; then
      if [ ! -d $i ]; then
        echo "$i already exists on filesystem and is not a dir"
      fi
    fi
  done
  exit 0
fi

if [ $1 == 'list-files' ]; then
  tar -tvf $2 | sed 's/kiin-dest//g' | tr -s ' ' | grep -E '^[-lpscbh].*' | cut -d ' ' --fields=6 | sort
  exit 0
fi

if [ $1 == 'list-dirs' ]; then
  tar -tvf $2 | sed 's/kiin-dest//g' | tr -s ' ' | grep -E '^d.*' | cut -d ' ' --fields=6 | sort
  exit 0
fi

if [ $1 == 'install' ]; then
  package=`echo $(basename $2) | sed 's/kiin\.//g' | sed 's/\.tar\.xz//g' | sed 's/-[^-]*$//g'`
  if [ `echo "select id from package where name='${package}';" | sqlite3 $KIIN_DB | wc -l` -gt 0 ]; then
    echo "Package with name $package is already installed. Aborting."
    exit 1
  fi
  if [ `kiin list-dups | wc -l` != '0' ]; then
    echo "where are duplicates in the system, not installing"
    exit 1
  fi
  if [ `kiin check-conflicts $2 | wc -l` != '0' ]; then
    echo "where are conflicts, not installing"
    exit 1
  fi
  startdir=`pwd`
  tmpdir=/tmp/kiin/`uuidgen`
  mkdir -p $tmpdir
  tar xf $2 -C $tmpdir
  for dir in `kiin list-dirs $2`; do
    if [ ! -d $dir ]; then
      prototype=$tmpdir/kiin-dest$dir
      mkdir -pv $dir
      chmod `stat -c %a $prototype` $dir
      #echo "chown `stat -c %U $prototype`:`stat -c %G $prototype` $dir"
    fi
  done
  for file in `kiin list-files $2`; do
    prototype=$tmpdir/kiin-dest$file
    cp -av $prototype $file
  done
  if [ -d $tmpdir/kiin-dest/usr/share/info ]; then
    recreate_info_dir
  fi
  cd $startdir
  sudo -u rybalkin mv -v $2 $KIIN_HOME/installed
  sudo -u rybalkin kiin gen-db
  exit 0
fi

if [ $1 == 'upgrade' ]; then
  if [ `kiin list-dups | wc -l` != '0' ]; then
    echo "where are duplicates in the system, not upgrading"
    exit 1
  fi
  package=`echo $(basename $2) | sed 's/kiin\.//g' | sed 's/\.tar\.xz//g' | sed 's/-[^-]*$//g'`
  check_system_packages $package $1
  new_version=`echo $(basename $2) | sed 's/kiin\.//g' | sed 's/\.tar\.xz//g' | sed "s/$package-//g"`
  old_version=`echo "select version from package where name='$package';" \
    | sqlite3 $KIIN_DB`
  if [ -z $old_version ]; then
    echo "no such package installed, sorry"
    exit 1
  fi
  startdir=`pwd`
  echo "upgrading $package from $old_version to $new_version" | tee -a $upgrade_log
  upgrade_log=/tmp/kiin/upgrade_log-`uuidgen`
  tmpdir=/tmp/kiin/`uuidgen`
  mkdir -p $tmpdir
  tar xf $2 -C $tmpdir
  for i in `kiin list-files $2`; do
    owners=`kiin who-owns $i`
    owner_count=`echo $owners | wc -w`
    [[ $owner_count = 0 ]] && [[ -e $i ]] && {
      echo "$i has no owners: $owners, but exists on filesystem, not upgrading"
      exit 1
    }
    [[ $owner_count > 0 ]] && [[ $owners != "$package-$old_version" ]] && {
      echo "$i has following owners: $owners, not upgrading"
      exit 1
    }
  done
  for i in `kiin list-dirs $2`; do
    i=`echo $i | sed 's/\/$//g'`
    if [ -e $i ]; then
      if [ ! -d $i ]; then
        echo "$i already exists on filesystem and is not a dir, not upgrading"
        exit 1
      fi
    fi
  done
  if [ ! "$3" = 'noask' ]; then
    echo "Following files are going to be deleted:"
    for file in `kiin db-list-files $package-$old_version`; do
      if [ ! -e $tmpdir/kiin-dest$file ]; then
        if [ ! -h $tmpdir/kiin-dest$file ]; then
          echo $file
        fi
      fi
    done
    read -p "Are you sure? (y/N)" answer
    case $answer in
      [Yy]* ) echo "let's go";;
      * ) echo "Answer was not y/Y, exiting."; exit 1;;
    esac
  fi
  # actual destructive shit
  # TODO: remove broken symbolic links to prevent
  # 'too many levels of symbolic links' error later
  for file in `kiin db-list-files $package-$old_version`; do
    if [ ! -e $tmpdir/kiin-dest$file ]; then
      if [ ! -h $tmpdir/kiin-dest$file ]; then
        rm -v $file 2>&1 | tee -a $upgrade_log
      fi
    fi
  done
  for dir in `kiin list-dirs $2`; do
    if [ ! -d $dir ]; then
      prototype=$tmpdir/kiin-dest$dir
      mkdir -pv $dir 2>&1 | tee -a $upgrade_log
      chmod -v `stat -c %a $prototype` $dir 2>&1 | tee -a $upgrade_log
    fi
  done
  for file in `kiin list-files $2`; do
    prototype=$tmpdir/kiin-dest$file
    # symlinks to folders: delete before "overwriting"
    if [ -h $file ]; then
      if [ -d $file ]; then
        rm -vf $file 2>&1 | tee -a $upgrade_log
      fi
    fi
    # the only place with overwriting
    cp -avf $prototype $file 2>&1 | tee -a $upgrade_log
  done
  for dir in `kiin db-list-dirs $package-$old_version \
    | awk '{ print length, $0 }' | sort -n -r | cut -d " " --fields=2`; do
    users=`kiin who-uses-dir $dir`
    user_count=`echo $users | wc -w`
    [[ $user_count = 1 ]] && [[ $users = "$package-$old_version" ]] && [[ ! -d $tmpdir/kiin-dest$dir ]] && {
      filecnt=`ls $dir | wc -w`
      if [ $filecnt -eq 0 ]; then
        rm -rv $dir 2>&1 | tee -a $upgrade_log
      fi
    }
  done
  if [ -d $tmpdir/kiin-dest/usr/share/info ]; then
    recreate_info_dir
  fi
  cd $startdir
  sudo -u rybalkin mv -v $KIIN_HOME/installed/kiin.$package-$old_version.tar.xz \
    $KIIN_HOME/uninstalled
  sudo -u rybalkin mv -v $2 $KIIN_HOME/installed
  sudo -u rybalkin kiin gen-db
  echo "upgrade log: $upgrade_log"
  exit 0
fi

if [ $1 == 'ls' ]; then
  echo "select name,version from package;" \
    | sqlite3 $KIIN_DB \
    | sed 's/|/\-/g' | sort -R
  exit 0
fi

if [ $1 == 'uninstall' ]; then
  if [ `kiin list-dups | wc -l` != '0' ]; then
    echo "where are duplicates in the system, not uninstalling"
    exit 1
  fi
  package_only=`echo $package | sed 's/-[^-]*$//g'`
  check_system_packages $package_only $1
  dependent=`kiin linked-by $package`
  linked_by_count=`echo $dependent | wc -w`
  if [ $linked_by_count -gt 0 ]; then
    echo "$package is linked by following packages: $dependent"
    echo "won't uninstall, bro."
    exit 1
  fi
  uninstall_log=/tmp/kiin/uninstall_log-`uuidgen`
  mkdir -p /tmp/kiin
  for file in `kiin db-list-files $package`; do
    rm -v $file 2>&1 | tee -a $uninstall_log
  done
  do_recreate_info_dir=0
  for dir in `kiin db-list-dirs $package \
    | awk '{ print length, $0 }' | sort -n -r | cut -d " " --fields=2`; do
    if [ $dir == "/usr/share/info/" ]; then
      do_recreate_info_dir=1
    fi
    users=`kiin who-uses-dir $dir`
    user_count=`echo $users | wc -w`
    [[ $user_count = 1 ]] && [[ $users = $package ]] && {
      filecnt=`ls $dir | wc -w`
      if [ $filecnt -eq 0 ]; then
        rm -rv $dir 2>&1 | tee -a $uninstall_log
      fi
    }
  done
  if [ $do_recreate_info_dir -eq 1 ]; then
    recreate_info_dir
  fi
  sudo -u rybalkin mv -v $KIIN_HOME/installed/kiin.$package.tar.xz \
    $KIIN_HOME/uninstalled
  sudo -u rybalkin kiin gen-db
  echo "uninstall_log: $uninstall_log"
  exit 0
fi

if [ $1 == 'db-list-files' ]; then
  package=`echo $package | sed 's/\-[^-]*$//g'`
  echo "select name from file where package_id in \
    (select id from package where name='$package') \
    and permissions not like 'd%';" \
    | sqlite3 $KIIN_DB | sort
  exit 0
fi

if [ $1 == 'db-list-dirs' ]; then
  package=`echo $package | sed 's/\-[^-]*$//g'`
  echo "select name from file where package_id in \
    (select id from package where name='$package') \
    and permissions like 'd%';" \
    | sqlite3 $KIIN_DB | sort
  exit 0
fi

if [ $1 == 'list-untracked' ]; then
  if [ ! -d $2 ]; then
    echo "dir $2 does not exist"
    exit 1
  fi
  dir=`echo $2 | sed 's/\/$//g'`
  find $dir ! -type d | db_manager.py list-untracked
  exit 0
fi

if [ $1 == 'check-system-integrity' ]; then
  dirs=
  for i in `ls /`; do
    if [ ! -z "`kiin who-uses-dir /$i | grep -v filesystem`" ]; then
      dirs="$dirs /$i"
    fi
  done
  echo " * searching for untracked files on filesystem..."
  echo " * used system dirs:" $dirs
  for i in $dirs; do
    kiin list-untracked $i
  done
  echo " * searching for missing package files..."
  kiin list-missing
  echo " * searching for duplications in package db..."
  kiin list-dups
  exit 0
fi

if [ $1 == 'list-missing' ]; then
  for package in `kiin ls`; do
    for file in `kiin db-list-files $package`; do
      if [ ! -e $file ]; then
        echo "$file is missing ($package)"
      fi
    done
  done
  exit 0
fi

# written by Dennis Williamson
# http://stackoverflow.com/questions/4023830/bash-how-compare-two-strings-in-version-format
vercomp () {
  if [[ $1 == $2 ]]; then
    return 0
  fi
  local IFS=.
  local i ver1=($1) ver2=($2)
  # fill empty fields in ver1 with zeros
  for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
    ver1[i]=0
  done
  for ((i=0; i<${#ver1[@]}; i++)); do
    if [[ -z ${ver2[i]} ]]; then
      # fill empty fields in ver2 with zeros
      ver2[i]=0
    fi
    if ((10#${ver1[i]} > 10#${ver2[i]})); then
      return 1
    fi
    if ((10#${ver1[i]} < 10#${ver2[i]})); then
      return 2
    fi
  done
  return 0
}

if [ $1 == 'prepare-check-updates' ]; then
  cd ~/sources/packages
  git pull
  cd ~/sources/community
  git pull
  cd $KIIN_HOME/src/linux
  git pull
  exit 0
fi

if [ $1 == 'check-updates' ]; then
  bldred='\e[1;31m'
  green='\e[0;32m'
  txtrst='\e[0m'
  #echo "checking git repos"
  package=linux
  cd $KIIN_HOME/src/$package
  newest_tag=`git for-each-ref --sort='*authordate' --format='%(tag)' refs/tags | tail -n 1`
  pkgver=`echo $newest_tag | sed 's/^v//g' | sed 's/-/\./g'`
  version=`echo "select version from package where name='${package}';" | sqlite3 $KIIN_DB`
  vercomp "$pkgver" "$version"
  cmp=$?
  if [ $cmp -ne 0 ]; then
    if [ $cmp -eq 2 ]; then
      :
      #echo -e "${green}  * ${package}${txtrst}: local is $version, newest in git is $pkgver (tag $newest_tag)"
    else
      echo -e "${bldred}  * ${package}${txtrst}: local is $version, newest in git is $pkgver (tag $newest_tag)"
    fi
  fi
  #echo "checking arch linux updates"
  cd ~/sources
  for i in `kiin ls`; do
    package=`echo $i | sed 's/\-[^-]*$//g'`
    version=`echo $i | sed "s/$package-//g"`
    local_package=$package
    # package name exceptions:
    [[ $package = 'python' ]] && package='python2'
    [[ $package = 'python2-virtualenv' ]] && package='python-virtualenv'
    [[ $package = 'python2-gobject2' ]] && package='pygobject2'
    [[ $package = 'python2-gtk' ]] && package='pygtk'
    [[ $package = 'python2-openssl' ]] && package='pyopenssl'
    [[ $package = 'python2-pyasn1' ]] && package='python-pyasn1'
    [[ $package = 'python2-crypto' ]] && package='pycrypto'
    [[ $package = 'mpc' ]] && package='libmpc'
    [[ $package = 'udev' ]] && package='systemd'
    [[ $package = 'glib' ]] && package='glib2'
    [[ $package = 'gdk-pixbuf' ]] && package='gdk-pixbuf2'
    [[ $package = 'mpd-mpc' ]] && package='mpc'
    [[ $package = 'device-mapper' ]] && package='lvm2'
    [[ $package = 'perl-ack' ]] && package='ack'
    [[ $package = 'lzo' ]] && package='lzo2'
    [[ $package = 'lib32-libtool' ]] && package='libtool-multilib'
    # package version exceptions:
    [[ $package = 'readline' ]] && [[ $version = '6.2' ]] && version='6.2.004'
    [[ $package = 'mpfr' ]] && [[ $version = '3.1.1' ]] && version='3.1.1.p2'
    [[ $package = 'sysvinit' ]] && [[ $version = '2.88dsf' ]] && version='2.88'
    [[ $package = 'openssl' ]] && [[ $version = '1.0.1c' ]] && version='1.0.1.c'
    [[ $package = 'sudo' ]] && [[ $version = '1.8.6p3' ]] && version='1.8.6.p3'
    # not found in Arch:
    [[ $package = 'sysklogd' ]] && continue
    [[ $package = 'xorg-makedepend' ]] && continue
    [[ $package = 'libpthread-stubs' ]] && continue
    [[ $package = 'python2-sh' ]] && continue
    [[ $package = 'libjpeg' ]] && continue
    # won't upgrade:
    [[ $package = 'linux' ]] && continue # we use and check git version
    [[ $package = 'initramfs' ]] && continue
    [[ $package = 'filesystem' ]] && continue
    [[ $package = 'linux-firmware' ]] && continue
    [[ $package = 'cacerts' ]] && continue
    [[ $package = 'kiin-git' ]] && continue
    [[ $package = 'kiin-known' ]] && continue
    if [ -d packages/$package ]; then
      . packages/$package/trunk/PKGBUILD
      vercomp "$pkgver" "$version"
      cmp=$?
      if [ $cmp -ne 0 ]; then
        if [ $cmp -eq 2 ]; then
          :
          #echo -e "${green}  * ${local_package}${txtrst}: local is $version, Arch's ($package) is $pkgver"
        else
          echo -e "${bldred}  * ${local_package}${txtrst}: local is $version, Arch's ($package) is $pkgver"
        fi
      fi
    else
      if [ -d community/$package ]; then
        . community/$package/trunk/PKGBUILD
        vercomp "$pkgver" "$version"
        cmp=$?
        if [ $cmp -ne 0 ]; then
          if [ $cmp -eq 2 ]; then
            :
            #echo -e "${green}  * ${local_package}${txtrst}: local is $version, Arch's ($package) is $pkgver"
          else
            echo -e "${bldred}  * ${local_package}${txtrst}: local is $version, Arch's ($package) is $pkgver"
          fi
        fi
      else
        echo "  cannot find $package in arch packages"
      fi
    fi
  done

  exit 0
fi

if [ $1 == 'update-links' ]; then
  package_name=`echo $package | sed 's/\-[^-]*$//g'`
  echo "updating links for $package_name..."
  user_package_id=`echo "select id from package where name='$package_name';" \
      | sqlite3 $KIIN_DB`
  echo "delete from depends where user_id=$user_package_id;" \
    | sqlite3 $KIIN_DB
  for i in `kiin db-list-files $package`; do
    if [ ! -r $i ]; then
      ldd_invocator='sudo ldd'
    else
      ldd_invocator='ldd'
    fi
    for j in `$ldd_invocator 2>/dev/null $i | grep -v "not a dynamic executable" \
        | sed 's/\ (0x.*$//g' | sed 's/^.*\ =>\ //g' \
        | sed 's/^[ \t]*//g' | grep -v "linux-vdso.so.1"`; do
      echo `readlink -m $j`
    done
  done | sed 's/\/lib64/\/lib/g' | sed 's/\/usr\/lib64/\/usr\/lib/g' \
    | sort | uniq | while read line; do
    kiin who-owns $line
  done | sort | uniq | while read dep_package; do
    dep_package_name=`echo $dep_package | sed 's/\-[^-]*$//g'`
    dep_package_id=`echo "select id from package where name='$dep_package_name';" \
       | sqlite3 $KIIN_DB`
    echo "insert into depends(user_id,provider_id) values \
      ($user_package_id, $dep_package_id);" \
      | sqlite3 $KIIN_DB
  done
  exit 0
fi

if [ $1 == 'links' ]; then
  package_name=`echo $package | sed 's/\-[^-]*$//g'`
  echo "select package.name from (select * from package join depends \
    on package.id=depends.user_id where name='$package_name') dep join package on \
    dep.provider_id=package.id where user_id <> provider_id;" \
    | sqlite3 $KIIN_DB
  exit 0
fi

if [ $1 == 'linked-by' ]; then
  package_name=`echo $package | sed 's/\-[^-]*$//g'`
  echo "select package.name from (select * from package join depends \
    on package.id=depends.provider_id where name='$package_name') dep join package on \
    dep.user_id=package.id where user_id <> provider_id;" \
    | sqlite3 $KIIN_DB
  exit 0
fi

if [ $1 == 'l' ]; then
  kiin links $package | sort && echo "---" && kiin linked-by $package | sort
  exit 0
fi

if [ $1 == 'check-buildorder' ]; then
  for i in `kiin ls`; do
    package=`echo $i | sed 's/\-[^-]*$//g'`
    grep -q $package $KIIN_HOME/buildorder
    if [ $? -gt 0 ]; then
      echo "$package is missing from buildorder"
    fi
  done
  for i in `cat $KIIN_HOME/buildorder`; do
    count=`echo "select * from package where name='$i';" | sqlite3 $KIIN_DB | wc -l`
    if [ $count -lt 1 ]; then
      echo "$i is not installed, but is in buildorder"
    fi
  done
  dups=`cat $KIIN_HOME/buildorder | sort | uniq -d`
  if [ ! -z $dups ]; then
    echo "duplicates in buildorder: $dups"
  fi
  echo "order offenders:"
  for i in `kiin ls`; do
    package=`echo $i | sed 's/\-[^-]*$//g'`
    order=`grep -n "^$package$" $KIIN_HOME/buildorder | cut -d ":" --fields 1`
    offending=""
    for j in `kiin links $i`; do
      dep_order=`grep -n "^$j$" $KIIN_HOME/buildorder | cut -d ":" --fields 1`
      if [ $dep_order -gt $order ]; then
        offending="$offending $j"
      fi
    done
    if [ ! -z "$offending" ]; then
      echo $package
      echo "    $offending"
    fi
  done
  exit 0
fi

if [ $1 == 'rebuild-world' ]; then
  set -e
  for package in `cat $KIIN_HOME/buildorder`; do
    # won't upgrade
    [[ $package = 'filesystem' ]] && continue
    [[ $package = 'kiin-git' ]] && continue
    [[ $package = 'kiin-known' ]] && continue
    [[ $package = 'linux-firmware' ]] && continue
    [[ $package = 'cacerts' ]] && continue

    # upgrade only manually
    [[ $package = 'linux-api-headers' ]] && continue
    [[ $package = 'glibc' ]] && continue
    [[ $package = 'ncurses' ]] && continue
    [[ $package = 'readline' ]] && continue
    [[ $package = 'linux' ]] && continue
    [[ $package = 'initramfs' ]] && continue

    # minor problems (segfault after installation)
    [[ $package = 'zlib' ]] && continue
    [[ $package = 'sudo' ]] && continue

    # build failed
    [[ $package = 'dhcpcd' ]] && continue

    lib32=0
    lib32test=`echo $package | grep lib32 | wc -w`
    if [ $lib32test -gt 0 ]; then
      package=`echo $package | sed 's/lib32\-//g'`
      lib32=1
    fi
    echo "rebuilding $package (lib32=$lib32)"
    sleep 3
    found=`find $KIIN_HOME/{base,essentials,crypt,dev,gui,multimedia,perl-modules,python2-modules,wireless,xorg} -type d -name $package`
    cd $found
    if [ $lib32 -eq 0 ]; then
      kiin make
    else
      kiin make lib32
    fi
    for pack in `find . -name 'kiin.*xz'`; do
      sudo kiin upgrade $pack noask
    done
  done
  exit 0
fi

if [ $1 == 'backup' ]; then
  # timings, sizes and upload times
  # gzip 227 seconds, 407 megabytes
  # bzip2 307 seconds, 355 megabytes
  echo "backup started."
  tmpdir=/tmp/kiin/backup-`uuidgen`
  backup_file=kiin.tar.bz2
  mkdir -p $tmpdir
  cd $tmpdir
  cat > Exclude << "EOF"
/boot/lost+found
/dev
/home
/lost+found
/proc
/root
/run
/sys
/tmp
/var/chroot
/var/kiin
EOF
  tar --exclude-from=Exclude -cpavf ${backup_file} /

  echo "backup ended."
  echo "${tmpdir}/${backup_file}"
  exit 0
fi

if [ $1 == 'convert-arch-package' ]; then
  echo "converting arch package..."
  if [ -f ${location}/${arch_tar} ]; then
    echo "${arch_tar} present"
  else
    wget ${arch_url}
  fi
  converter=${location}/kiin_converter.sh
  cat > ${converter} << "EOF"
#!/bin/sh
cd ${location}
. ./package.sh
mkdir ${pkgdir}
tar xvf ${arch_tar} -C ${pkgdir}
rm ${pkgdir}/.PKGINFO
rm ${pkgdir}/.INSTALL

# fix /usr/share/info/dir
rm -fv ${pkgdir}/usr/share/info/dir
if [ -e ${pkgdir}/var ]; then
  echo " *** WARNING ***: package tries to use /var"
fi

# remove *.la files
if [ -d ${pkgdir}/lib ]; then
  find ${pkgdir}/lib -name "*.la" | xargs rm -vf
fi
if [ -d ${pkgdir}/usr/lib ]; then
  find ${pkgdir}/usr/lib -name "*.la" | xargs rm -vf
fi
if [ -d ${pkgdir}/usr/lib32 ]; then
  find ${pkgdir}/usr/lib32 -name "*.la" | xargs rm -vf
fi

rm -rf ${pkgdir}/usr/share/licenses

if [ ${pkgname} == 'lib32-glibc' ]; then
  mkdir ${pkgdir}/lib
  ln -sv /usr/lib32/ld-linux.so.2 ${pkgdir}/lib/ld-linux.so.2
fi

cd ${location}
echo creating xz archive...
tar cfa kiin.${pkgname}-${pkgver}.tar.xz kiin-dest
EOF
  chmod +x ${converter}
  location=${location} srcdir=${srcdir} pkgdir=${pkgdir} \
    pkgname=${pkgname} pkgver=${pkgver} fakeroot ${converter}
  rm ${converter}
  rm -rf ${pkgdir}
  echo "done."
  exit 0
fi

usage
