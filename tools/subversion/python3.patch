diff --git a/build/generator/swig/__init__.py b/build/generator/swig/__init__.py
index 2ecfe4b931..98cb4321e7 100644
--- a/build/generator/swig/__init__.py
+++ b/build/generator/swig/__init__.py
@@ -72,7 +72,7 @@ class Generator:
 
     if not self._swigVersion:
       swig_version = subprocess.check_output([self.swig_path, "-version"])
-      m = re.search("Version (\d+).(\d+).(\d+)", swig_version)
+      m = re.search(b"Version (\d+).(\d+).(\d+)", swig_version)
       if m:
         self._swigVersion = tuple(map(int, m.groups()))
       else:
diff --git a/build/generator/swig/header_wrappers.py b/build/generator/swig/header_wrappers.py
index 6c3533d46c..0b85fb54ad 100755
--- a/build/generator/swig/header_wrappers.py
+++ b/build/generator/swig/header_wrappers.py
@@ -80,20 +80,20 @@ class Generator(generator.swig.Generator):
 
   def _write_nodefault_calls(self, structs):
     """Write proxy definitions to a SWIG interface file"""
-    self.ofile.write("\n/* No default constructors for opaque structs */\n")
-    self.ofile.write('#ifdef SWIGPYTHON\n');
+    self.ofile.write(b"\n/* No default constructors for opaque structs */\n")
+    self.ofile.write(b'#ifdef SWIGPYTHON\n');
     for structName, structDefinition in structs:
       if not structDefinition:
-        self.ofile.write('%%nodefault %s;\n' % structName)
-    self.ofile.write('#endif\n');
+        self.ofile.write(b'%%nodefault %s;\n' % structName.encode())
+    self.ofile.write(b'#endif\n');
 
   def _write_includes(self, includes, base_fname):
     """Write includes to a SWIG interface file"""
 
-    self.ofile.write('\n/* Includes */\n')
-    self.ofile.write('%%{\n#include "%s"\n%%}\n' % base_fname)
+    self.ofile.write(b'\n/* Includes */\n')
+    self.ofile.write(b'%%{\n#include "%s"\n%%}\n' % base_fname.encode())
     if base_fname not in self._ignores:
-      self.ofile.write('%%include %s\n' % base_fname)
+      self.ofile.write(b'%%include %s\n' % base_fname.encode())
 
 
   def _write_callback(self, type, return_type, module, function, params,
@@ -118,56 +118,56 @@ class Generator(generator.swig.Generator):
 
     # Write out the declaration
     self.ofile.write(
-      "static %s %s_invoke_%s(\n" % (return_type, module, function) +
-      "  %s) {\n" % params +
-      "  %s;\n" % invoke_callback +
-      "}\n\n")
+      b"static %s %s_invoke_%s(\n" % (return_type.encode(), module.encode(), function.encode()) +
+      b"  %s) {\n" % params.encode() +
+      b"  %s;\n" % invoke_callback.encode() +
+      b"}\n\n")
 
 
   def _write_callback_typemaps(self, callbacks):
     """Apply the CALLABLE_CALLBACK typemap to all callbacks"""
 
-    self.ofile.write('\n/* Callback typemaps */\n')
+    self.ofile.write(b'\n/* Callback typemaps */\n')
     types = [];
     for match in callbacks:
       if match[0] and match[1]:
         # Callbacks declared as a typedef
         return_type, module, function, params = match
-        type = "%s_%s_t" % (module, function)
+        type = b"%s_%s_t" % (module.encode(), function.encode())
         types.append(type)
 
     if types:
       self.ofile.write(
-        "#ifdef SWIGPYTHON\n"
-        "%%apply CALLABLE_CALLBACK {\n"
-        "  %s\n"
-        "};\n"
-        "%%apply CALLABLE_CALLBACK * {\n"
-        "  %s *\n"
-        "};\n"
-        "#endif\n" % ( ",\n  ".join(types), " *,\n  ".join(types) )
+        b"#ifdef SWIGPYTHON\n"
+        b"%%apply CALLABLE_CALLBACK {\n"
+        b"  %s\n"
+        b"};\n"
+        b"%%apply CALLABLE_CALLBACK * {\n"
+        b"  %s *\n"
+        b"};\n"
+        b"#endif\n" % ( b",\n  ".join(types), b" *,\n  ".join(types) )
       );
 
 
   def _write_baton_typemaps(self, batons):
     """Apply the PY_AS_VOID typemap to all batons"""
 
-    self.ofile.write('\n/* Baton typemaps */\n')
+    self.ofile.write(b'\n/* Baton typemaps */\n')
 
     if batons:
       self.ofile.write(
-        "#ifdef SWIGPYTHON\n"
-        "%%apply void *PY_AS_VOID {\n"
-        "  void *%s\n"
-        "};\n"
-        "#endif\n" % ( ",\n  void *".join(batons) )
+        b"#ifdef SWIGPYTHON\n"
+        b"%%apply void *PY_AS_VOID {\n"
+        b"  void *%s\n"
+        b"};\n"
+        b"#endif\n" % ( b",\n  void *".join([b.encode() for b in batons]) )
       )
 
 
   def _write_callbacks(self, callbacks):
     """Write invoker functions for callbacks"""
-    self.ofile.write('\n/* Callbacks */\n')
-    self.ofile.write("\n%inline %{\n")
+    self.ofile.write(b'\n/* Callbacks */\n')
+    self.ofile.write(b"\n%inline %{\n")
 
     struct = None
     for match in callbacks:
@@ -190,9 +190,9 @@ class Generator(generator.swig.Generator):
           self._write_callback(type, return_type, module, function, params,
                                "_obj")
 
-    self.ofile.write("%}\n")
+    self.ofile.write(b"%}\n")
 
-    self.ofile.write("\n#ifdef SWIGPYTHON\n")
+    self.ofile.write(b"\n#ifdef SWIGPYTHON\n")
     for match in callbacks:
 
       if match[0] and not match[1]:
@@ -202,28 +202,28 @@ class Generator(generator.swig.Generator):
         # Using funcptr_member_proxy, add proxy methods to anonymous
         # struct member callbacks, so that they can be invoked directly.
         return_type, name, params = match[1:]
-        self.ofile.write('%%funcptr_member_proxy(%s, %s, %s_invoke_%s);\n'
-          % (struct, name, struct[:-2], name))
+        self.ofile.write(b'%%funcptr_member_proxy(%s, %s, %s_invoke_%s);\n'
+          % (struct.encode(), name.encode(), struct[:-2].encode(), name.encode()))
       elif match[0] and match[1]:
         # Using funcptr_proxy, create wrapper objects for each typedef'd
         # callback, so that they can be invoked directly. The
         # CALLABLE_CALLBACK typemap (used in _write_callback_typemaps)
         # ensures that these wrapper objects are actually used.
         return_type, module, function, params = match
-        self.ofile.write('%%funcptr_proxy(%s_%s_t, %s_invoke_%s);\n'
-          % (module, function, module, function))
-    self.ofile.write("\n#endif\n")
+        self.ofile.write(b'%%funcptr_proxy(%s_%s_t, %s_invoke_%s);\n'
+          % (module.encode(), function.encode(), module.encode(), function.encode()))
+    self.ofile.write(b"\n#endif\n")
 
   def _write_proxy_definitions(self, structs):
     """Write proxy definitions to a SWIG interface file"""
-    self.ofile.write('\n/* Structure definitions */\n')
-    self.ofile.write('#ifdef SWIGPYTHON\n');
+    self.ofile.write(b'\n/* Structure definitions */\n')
+    self.ofile.write(b'#ifdef SWIGPYTHON\n');
     for structName, structDefinition in structs:
       if structDefinition:
-        self.ofile.write('%%proxy(%s);\n' % structName)
+        self.ofile.write(b'%%proxy(%s);\n' % structName.encode())
       else:
-        self.ofile.write('%%opaque_proxy(%s);\n' % structName)
-    self.ofile.write('#endif\n');
+        self.ofile.write(b'%%opaque_proxy(%s);\n' % structName.encode())
+    self.ofile.write(b'#endif\n');
 
   """Regular expression for parsing includes from a C header file"""
   _re_includes = re.compile(r'#\s*include\s*[<"]([^<">;\s]+)')
@@ -266,9 +266,9 @@ class Generator(generator.swig.Generator):
 
     # Open a temporary output file
     self.ofile = tempfile.TemporaryFile(dir=self.proxy_dir)
-    self.ofile.write('/* Proxy classes for %s\n' % base_fname)
-    self.ofile.write(' * DO NOT EDIT -- AUTOMATICALLY GENERATED\n')
-    self.ofile.write(' * BY build/generator/swig/header_wrappers.py */\n')
+    self.ofile.write(b'/* Proxy classes for %s\n' % base_fname.encode())
+    self.ofile.write(b' * DO NOT EDIT -- AUTOMATICALLY GENERATED\n')
+    self.ofile.write(b' * BY build/generator/swig/header_wrappers.py */\n')
 
     # Write list of structs for which we shouldn't define constructors
     # by default
@@ -294,7 +294,7 @@ class Generator(generator.swig.Generator):
     # but NamedTemporaryFile() only supports its 'delete' parameter
     # in python 2.6 and above, and renaming the file while it's opened
     # exclusively is probably not a good idea.
-    outputfile = open(output_fname, 'w')
+    outputfile = open(output_fname, 'bw')
     self.ofile.seek(0)
     shutil.copyfileobj(self.ofile, outputfile)
 
