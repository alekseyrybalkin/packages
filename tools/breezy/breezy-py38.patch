=== modified file 'breezy/_static_tuple_c.c'
--- breezy/_static_tuple_c.c	2017-06-27 00:56:24 +0000
+++ breezy/_static_tuple_c.c	2019-10-16 22:57:55 +0000
@@ -320,6 +320,78 @@
     return result;
 }
 
+/* adapted from tuplehash(), is the specific hash value considered
+ * 'stable'?
+ */
+
+#if PY_MAJOR_VERSION > 3 || (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION >= 8)
+/* Hash for tuples. This is a slightly simplified version of the xxHash
+   non-cryptographic hash:
+   - we do not use any parallellism, there is only 1 accumulator.
+   - we drop the final mixing since this is just a permutation of the
+     output space: it does not help against collisions.
+   - at the end, we mangle the length with a single constant.
+   For the xxHash specification, see
+   https://github.com/Cyan4973/xxHash/blob/master/doc/xxhash_spec.md
+
+   Below are the official constants from the xxHash specification. Optimizing
+   compilers should emit a single "rotate" instruction for the
+   _PyHASH_XXROTATE() expansion. If that doesn't happen for some important
+   platform, the macro could be changed to expand to a platform-specific rotate
+   spelling instead.
+*/
+#if SIZEOF_PY_UHASH_T > 4
+#define _PyHASH_XXPRIME_1 ((Py_uhash_t)11400714785074694791ULL)
+#define _PyHASH_XXPRIME_2 ((Py_uhash_t)14029467366897019727ULL)
+#define _PyHASH_XXPRIME_5 ((Py_uhash_t)2870177450012600261ULL)
+#define _PyHASH_XXROTATE(x) ((x << 31) | (x >> 33))  /* Rotate left 31 bits */
+#else
+#define _PyHASH_XXPRIME_1 ((Py_uhash_t)2654435761UL)
+#define _PyHASH_XXPRIME_2 ((Py_uhash_t)2246822519UL)
+#define _PyHASH_XXPRIME_5 ((Py_uhash_t)374761393UL)
+#define _PyHASH_XXROTATE(x) ((x << 13) | (x >> 19))  /* Rotate left 13 bits */
+#endif
+
+/* Tests have shown that it's not worth to cache the hash value, see
+   https://bugs.python.org/issue9685 */
+static Py_hash_t
+StaticTuple_hash(StaticTuple *self)
+{
+    Py_ssize_t i, len = self->size;
+    PyObject **item = self->items;
+
+#if STATIC_TUPLE_HAS_HASH
+    if (self->hash != -1) {
+        return self->hash;
+    }
+#endif
+
+    Py_uhash_t acc = _PyHASH_XXPRIME_5;
+    for (i = 0; i < len; i++) {
+        Py_uhash_t lane = PyObject_Hash(item[i]);
+        if (lane == (Py_uhash_t)-1) {
+            return -1;
+        }
+        acc += lane * _PyHASH_XXPRIME_2;
+        acc = _PyHASH_XXROTATE(acc);
+        acc *= _PyHASH_XXPRIME_1;
+    }
+
+    /* Add input length, mangled to keep the historical value of hash(()). */
+    acc += len ^ (_PyHASH_XXPRIME_5 ^ 3527539UL);
+
+    if (acc == (Py_uhash_t)-1) {
+        acc = 1546275796;
+    }
+
+#if STATIC_TUPLE_HAS_HASH
+    self->hash = acc;
+#endif
+    return acc;
+}
+
+
+#else
 static long
 StaticTuple_hash(StaticTuple *self)
 {
@@ -357,6 +429,7 @@
 #endif
     return x;
 }
+#endif
 
 static PyObject *
 StaticTuple_richcompare_to_tuple(StaticTuple *v, PyObject *wt, int op)

=== modified file 'breezy/bzr/_dirstate_helpers_pyx.pyx'
--- breezy/bzr/_dirstate_helpers_pyx.pyx	2019-09-22 02:25:23 +0000
+++ breezy/bzr/_dirstate_helpers_pyx.pyx	2019-10-16 22:57:55 +0000
@@ -109,6 +109,9 @@
     int PyBytes_Size(object p)
     int PyBytes_GET_SIZE_void "PyBytes_GET_SIZE" (void *p)
     int PyBytes_CheckExact(object p)
+    int PyFloat_Check(object p)
+    double PyFloat_AsDouble(object p)
+    int PyLong_Check(object p)
     void Py_INCREF(object o)
     void Py_DECREF(object o)
 
@@ -794,6 +797,16 @@
 _encode = binascii.b2a_base64
 
 
+cdef unsigned long _time_to_unsigned(object t):
+    cdef double dt
+    if PyLong_Check(t):
+        return PyInt_AsUnsignedLongMask(t)
+    if PyFloat_Check(t):
+        dt = PyFloat_AsDouble(t)
+        return <unsigned long>dt
+    raise TypeError("invalid type for time: %r" % t)
+
+
 cdef _pack_stat(stat_value):
     """return a string representing the stat value's key fields.
 
@@ -805,8 +818,8 @@
     aliased = <int *>result
     aliased[0] = htonl(PyInt_AsUnsignedLongMask(stat_value.st_size))
     # mtime and ctime will often be floats but get converted to PyInt within
-    aliased[1] = htonl(PyInt_AsUnsignedLongMask(stat_value.st_mtime))
-    aliased[2] = htonl(PyInt_AsUnsignedLongMask(stat_value.st_ctime))
+    aliased[1] = htonl(_time_to_unsigned(stat_value.st_mtime))
+    aliased[2] = htonl(_time_to_unsigned(stat_value.st_ctime))
     aliased[3] = htonl(PyInt_AsUnsignedLongMask(stat_value.st_dev))
     aliased[4] = htonl(PyInt_AsUnsignedLongMask(stat_value.st_ino))
     aliased[5] = htonl(PyInt_AsUnsignedLongMask(stat_value.st_mode))

=== modified file 'breezy/git/remote.py'
--- breezy/git/remote.py	2019-08-11 16:27:38 +0000
+++ breezy/git/remote.py	2019-10-16 22:57:55 +0000
@@ -123,10 +123,10 @@
 
 try:
     import urllib.parse as urlparse
-    from urllib.parse import splituser, splitnport
+    from urllib.parse import splituser
 except ImportError:
     import urlparse
-    from urllib import splituser, splitnport
+    from urllib import splituser
 
 # urlparse only supports a limited number of schemes by default
 register_urlparse_netloc_protocol('git')
@@ -165,13 +165,11 @@
     :param url: Git URL
     :return: Tuple with host, port, username, path.
     """
-    (scheme, netloc, loc, _, _) = urlparse.urlsplit(url)
-    path = urlparse.unquote(loc)
+    parsed_url = urlparse.urlparse(url)
+    path = urlparse.unquote(parsed_url.path)
     if path.startswith("/~"):
         path = path[1:]
-    (username, hostport) = splituser(netloc)
-    (host, port) = splitnport(hostport, None)
-    return (host, port, username, path)
+    return ((parsed_url.hostname or '', parsed_url.port, parsed_url.username, path))
 
 
 class RemoteGitError(BzrError):

=== modified file 'breezy/git/tests/test_remote.py'
--- breezy/git/tests/test_remote.py	2019-08-06 07:11:09 +0000
+++ breezy/git/tests/test_remote.py	2019-10-16 22:57:55 +0000
@@ -65,6 +65,11 @@
         self.assertEqual(("foo", None, "la", "/bar"),
                          split_git_url("git://la@foo/bar"))
 
+    def test_username_password(self):
+        self.assertEqual(
+            ("foo", None, "la", "/bar"),
+            split_git_url("git://la:passwd@foo/bar"))
+
     def test_nopath(self):
         self.assertEqual(("foo", None, None, "/"),
                          split_git_url("git://foo/"))
@@ -77,6 +82,10 @@
         self.assertEqual(("foo", None, None, "~bar"),
                          split_git_url("git://foo/~bar"))
 
+    def test_file(self):
+        self.assertEqual(("", None, None, "/bar"),
+                split_git_url("file:///bar"))
+
 
 class ParseGitErrorTests(TestCase):
 

=== modified file 'breezy/tests/test_server.py'
--- breezy/tests/test_server.py	2018-11-12 01:41:38 +0000
+++ breezy/tests/test_server.py	2019-10-16 22:57:55 +0000
@@ -249,6 +249,10 @@
 
 class TestThread(cethread.CatchingExceptionThread):
 
+    if not getattr(cethread.CatchingExceptionThread, 'is_alive', None):
+        def is_alive(self):
+            return self.isAlive()
+
     def join(self, timeout=5):
         """Overrides to use a default timeout.
 
@@ -256,7 +260,7 @@
         serving a client connection is hung.
         """
         super(TestThread, self).join(timeout)
-        if timeout and self.isAlive():
+        if timeout and self.is_alive():
             # The timeout expired without joining the thread, the thread is
             # therefore stucked and that's a failure as far as the test is
             # concerned. We used to hang here.
 

